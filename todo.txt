First Step: 

OpenGL

How Krill should work:

Krill is a component based game engine, which will behave similarly to Unity.

One initially needs to set up an instace of Krill using:

    Krill krill(argc, argv);

In order to create a game object, one must inherit from the Krill game object class

    class Enemy : public GameObject()
    {
        ...
Every GameObject child will have default functions which will be called at certain times, such as

    Enemy::OnCreate()
    Enemy::OnStart()
    Enemy::OnUpdate()
    Enemy::OnDestroy()

and so on...

Every GameObject will have a set of GameComponents, which will handle the underlying calls to the main engine. One can create their own components:

    class EnemyAI : public GameComponent()
    {

Every GameComponent will have their own set of default functions

    EnemyAI::OnStart()
    EnemyAI::OnUpdate()

Krill will also offer a set of default components such as

    Transform::Transform
    Renderer::Renderer2D
    Audio::AudioClient


Let's see an example:


    class EnemyAI : public GameComponent
    {
        public:
            EnemyAI(GameObject object) : Master(object);
            void SetMainCharacter(GameObject *_mainCharater)
            {
                mainCharacter = _mainCharater;
            }
            void OnUpdate()
            {
                transform.Position += speed * Math.normalize(mainCharacter.transform.Position - transform.Position);
            }
        private:
            GameObject *mainCharacter;
            float speed = 2.0;
    };

    class Enemy : public GameObject
    {
        public:
            Enemy : enemyAI(this) {}
            void OnStart()
            {
                GameObject *mc = Krill.Krill().GetObjectByTag("MainCharacter");
                enemyAI.SetMainCharacter(mc);
            }
        private:
            EnemyAI enemyAI;
    }

//

How to design the essential components:

We wish to be able to switch between renderers easily. For example, if we want to switch from 2D to 3D, instead of using

    class Enemey : public GameObject
    {
        private:
        Renderer::Renderer2D renderer;

we will simply switch to

    class Enemy :: public GameObject
    {
        private:
        Renderer::Render3D renderer;

and be on our way.

However, in order to avoid creating a shit ton of singletons, we are going to need to make some cuts.

Krill is going to handle all lower level stuff, including graphics, audio, input/output, Physics

In order to communicate with Krill, each object will use a GameComponent.

--

The graphics engine will be 3D, and use OpenGL with GLFW.


--

How are games created:

What are levels?

Levels are just a list of GameObjects which should be instantiated at the beggining.

We need something to manage all of the levels?

Yes. Call it World. A world is a set of GameObjects.

You should be able to instantiate a new object by calling

World::Instantiate(GameObject *);

Maybe every game object should also have this method? That way we can create child objects. Makes sense

for example, if we have a Monster Spawner, we can make

    class MonsterSpawner : public GameObject
    {
        void Loop()
        {
            this->Instantiate(Monster);
        }
        void Destroy()
        {
            for(auto& monster : ChildObjects)
            {
                monster.Destroy();
            }
        }
        GameObject *Monster;
    }

In this instance, World will be the only GameObject that actually exists. Krill will have it. Krill will not need to have a list of GameObjects.

Simply one: World.

On every Loop function, a father should invoke the loop function of every one of it's children.

In order to make this more clean, there should be non virtual loop functions.

For example:

    class GameObject
    {
        virtual void Update(){}
        void InvokeUpdate()
        {
            Update();
            for(auto &child : ChildObjects)
            {
                child.InvokeUpdate();
            }
        }


//

Update functions should be run on a certain order, particularly the update functions of GameComponents

You want the animation to end BEFORE invoking the rendering function.

Krill is going to have update blocks. So, each loop will consist of 

Initialization Block
Physics Block
Input Block
AnimationBlock
LogicBlock
GameObjectBlock
RenderingBlock
PostRenderingBlock

You can add another block by invoking

Krill::Krill().CreateEventBlock(BlockName, index);

Every GameComponent should register their update function within a block

    class EnemyAI : public GameComponent
    {
        EnemyAI : GameComponent(LogicBlock, ...){}
        ...

